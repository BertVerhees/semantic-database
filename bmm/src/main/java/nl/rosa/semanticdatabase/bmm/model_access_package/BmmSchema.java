package nl.rosa.semanticdatabase.bmm.model_access_package;

import java.util.Objects;

import nl.rosa.semanticdatabase.bmm.model_structure.BmmModel;

/**
 * #Generated: 2020-11-26T17:29:11.503+01:00
 * #Copyright: Bert Verhees
 * #License: See bottom of file
 * <p>
 * Abstract parent of any persistable form of a BMM model, e.g.
 * P_BMM_SCHEMA.
 */
public abstract class BmmSchema implements BmmModelMetadata {

    //***** BmmSchema *****

    /*=========================================================*/
    /* * FIELDS * */
    /*=========================================================*/

    /**
     * Version of BMM model, enabling schema evolution reasoning.
     * Persisted attribute.
     * cardinality: 1..1
     */
    private String bmmVersion;

    /**
     * Inclusion list of any form of BMM model, in the form of a hash of individual include specifications, each of which at least specifies the id of another schema, and may specify a namespace via which types from the included schemas are known in this schema.
     * Persisted attribute.
     * cardinality: 0..1
     */
    private Map<String, BmmIncludeSpec> includes;

    /**
     * Generated by create_bmm_model from persisted elements.
     * cardinality: 0..1
     */
    private BmmModel bmmModel;

    /**
     * Current processing state.
     * cardinality: 1..1
     */
    private BmmSchemaState state;

    /**
     * Name of this model, if this schema is a model root point.
     * Not set for sub-schemas that are not considered models on their own.
     * cardinality: 0..1
     */
    private String modelName;

    /**
     * Name of model expressed in schema; a 'schema' usually contains all of the packages of one 'model' of a publisher.
     * A publisher with more than one model can have multiple schemas.
     * cardinality: 1..1
     */
    private String schemaName;

    /**
     * Revision of schema.
     * cardinality: 1..1
     */
    private String schemaRevision;

    /**
     * Schema development lifecycle state.
     * cardinality: 1..1
     */
    private String schemaLifecycleState;

    /**
     * Primary author of schema.
     * cardinality: 1..1
     */
    private String schemaAuthor;

    /**
     * Description of schema.
     * cardinality: 1..1
     */
    private String schemaDescription;

    /**
     * Contributing authors of schema.
     * cardinality: 0..1
     */
    private List<String> schemaContributors;

/**
 *
 * Main validation prior to generation of bmm_model.
 * cardinality: 0..1 (abstract)
 *
 */
    private;

    /*=========================================================*/
    /* * POJOS * */
    /*=========================================================*/

    /**
     * Version of BMM model, enabling schema evolution reasoning.
     * Persisted attribute.
     * cardinality: 1..1
     */
    public String getBmmVersion() {
        return bmmVersion;
    }

    public void setBmmVersion(String value) {
        if (value == null) {
            throw new NullPointerException(" Setting property:bmmVersion failed, it has cardinality NonNull, but is null");
        }
        this.bmmVersion = bmmVersion;
    }

    /**
     * Inclusion list of any form of BMM model, in the form of a hash of individual include specifications, each of which at least specifies the id of another schema, and may specify a namespace via which types from the included schemas are known in this schema.
     * Persisted attribute.
     * cardinality: 0..1
     */

    public void putInclude(String key, BmmIncludeSpec value) {
        if (includes == null) {
            includes = new HashMap<>();
        }
        includes.put(key, value);
    }

    public void putIncludes(Map<String, BmmIncludeSpec> items) {
        items.keySet().forEach(key -> putInclude(key, items.get(key)));
    }

    public BmmIncludeSpec getInclude(String key) {
        if (includes == null) {
            return null;
        }
        return includes.get(key);
    }

    public void removeInclude(String key) {
        if (includes != null) {
            includes.remove(key);
        }
    }

    public void removeIncludes(Collection<String> keys) {
        keys.forEach(this::removeInclude);
    }

    public Map<String, BmmIncludeSpec> getIncludes() {
        return this.includes;
    }

    public BmmSchema setIncludes(Map<String, BmmIncludeSpec> includes) {
        this.includes = includes;
        return this;
    }

    public Map<String, BmmIncludeSpec> includes() {
        return Collections.unmodifiableMap(this.includes);
    }

    /**
     * Generated by create_bmm_model from persisted elements.
     * cardinality: 0..1
     */
    public BmmModel getBmmModel() {
        return bmmModel;
    }

    public void setBmmModel(BmmModel value) {
        this.bmmModel = bmmModel;
    }

    /**
     * Current processing state.
     * cardinality: 1..1
     */
    public BmmSchemaState getState() {
        return state;
    }

    public void setState(BmmSchemaState value) {
        if (value == null) {
            throw new NullPointerException(" Setting property:state failed, it has cardinality NonNull, but is null");
        }
        this.state = state;
    }

    /**
     * Name of this model, if this schema is a model root point.
     * Not set for sub-schemas that are not considered models on their own.
     * cardinality: 0..1
     */
    public String getModelName() {
        return modelName;
    }

    public void setModelName(String value) {
        this.modelName = modelName;
    }

    /**
     * Name of model expressed in schema; a 'schema' usually contains all of the packages of one 'model' of a publisher.
     * A publisher with more than one model can have multiple schemas.
     * cardinality: 1..1
     */
    public String getSchemaName() {
        return schemaName;
    }

    public void setSchemaName(String value) {
        if (value == null) {
            throw new NullPointerException(" Setting property:schemaName failed, it has cardinality NonNull, but is null");
        }
        this.schemaName = schemaName;
    }

    /**
     * Revision of schema.
     * cardinality: 1..1
     */
    public String getSchemaRevision() {
        return schemaRevision;
    }

    public void setSchemaRevision(String value) {
        if (value == null) {
            throw new NullPointerException(" Setting property:schemaRevision failed, it has cardinality NonNull, but is null");
        }
        this.schemaRevision = schemaRevision;
    }

    /**
     * Schema development lifecycle state.
     * cardinality: 1..1
     */
    public String getSchemaLifecycleState() {
        return schemaLifecycleState;
    }

    public void setSchemaLifecycleState(String value) {
        if (value == null) {
            throw new NullPointerException(" Setting property:schemaLifecycleState failed, it has cardinality NonNull, but is null");
        }
        this.schemaLifecycleState = schemaLifecycleState;
    }

    /**
     * Primary author of schema.
     * cardinality: 1..1
     */
    public String getSchemaAuthor() {
        return schemaAuthor;
    }

    public void setSchemaAuthor(String value) {
        if (value == null) {
            throw new NullPointerException(" Setting property:schemaAuthor failed, it has cardinality NonNull, but is null");
        }
        this.schemaAuthor = schemaAuthor;
    }

    /**
     * Description of schema.
     * cardinality: 1..1
     */
    public String getSchemaDescription() {
        return schemaDescription;
    }

    public void setSchemaDescription(String value) {
        if (value == null) {
            throw new NullPointerException(" Setting property:schemaDescription failed, it has cardinality NonNull, but is null");
        }
        this.schemaDescription = schemaDescription;
    }

    /**
     * Contributing authors of schema.
     * cardinality: 0..1
     */

    public void addToSchemaContributor(String value) {
        if (schemaContributors == null) {
            schemaContributors = new ArrayList<>();
        }
        schemaContributors.add(value);
    }

    public void addToSchemaContributors(List<String> values) {
        values.forEach(value -> addToSchemacontributor(value));
    }

    public void removeFromSchemaContributor(String item) {
        if (schemaContributors != null) {
            schemaContributors.remove(item);
        }
    }

    public void removeFromSchemaContributors(Collection<String> values) {
        values.forEach(this::removeFromSchemaContributor);
    }

    List<String> getSchemaContributors() {
        return this.schemaContributors;
    }

    public BmmSchema setSchemaContributors(List<String> schemaContributors) {
        this.schemaContributors = schemaContributors;
        return this;
    }

    public List<String> schemaContributors() {
        return Collections.unmodifiableList(this.schemaContributors);
    }

    /**
     * Main validation prior to generation of bmm_model.
     * cardinality: 0..1 (abstract)
     */
    public get() {
        return;
    }

    public void set(value) {
        this. =;
    }

    /*=========================================================*/
    /* * FUNCTIONS * */
    /*=========================================================*/

/**
 *
 * Merge in class and package definitions from other, except where the current schema already has a definition for the given type or package.
 * cardinality: 0..1 (abstract)
 *
 */
    public abstract includes_to_process.has(included_schema.schema_id)

    merge(BmmSchema other);

/**
 *
 * True when validation may be commenced.
 * cardinality: 1..1
 *
 */
    public state =

    State_includes_processed readToValidate() {
        state = State_includes_processed result = null;


        if (result == null) {
            throw new NullPointerException("Return-value has cardinality NonNull, but is null.");
        }
        return result;
    }

    /**
     * Identifier of this schema, used for stating inclusions and identifying files.
     * Formed as: {BMM_DEFINITIONS}.create_schema_id ( rm_publisher, schema_name, rm_release) E.g.
     * "openehr_rm_ehr_1.0.4".
     * cardinality: 1..1
     */
    public String schemaId() {
        String result = null;


        if (result == null) {
            throw new NullPointerException("Return-value has cardinality NonNull, but is null.");
        }
        return result;
    }

    /*=========================================================*/
    /* * CONSTANTS * */
    /*=========================================================*/

    /**
     * Do some basic validation post initial creation check that package structure is regular: only top-level packages can have qualified names no top-level package name can be a direct parent or child of another (child package must be declared under the parent) check that all classes are mentioned in the package structure check that all models refer to valid packages
     */
    final state validateCreated
    preState =
    State_created Post_state:
    passed implies
    state =State_validated_created;

    /**
     * Finalisation work: convert packages to canonical form, i.e.
     * full hierarchy with no packages with names like aa.bb.cc set up include processing list
     */
    final state loadFinalise
    preState =
    State_validated_created Post_state:state =
    State_includes_processed or
    state =State_includes_pending;

    /**
     * Populate bmm_model from schema.
     */
    final state createBmmModel
    preState =P_BMM_PACKAGE_STATE.State_includes_processed;

    //***** BmmModelMetadata *****

    /*=========================================================*/
    /* * FIELDS * */
    /*=========================================================*/

    /**
     * Publisher of model expressed in the schema.
     * cardinality: 1..1
     */
    private String rmPublisher;

    /**
     * Release of model expressed in the schema as a 3-part numeric, e.g.
     * "3.1.0" .
     * cardinality: 1..1
     */
    private String rmRelease;

    /*=========================================================*/
    /* * POJOS * */
    /*=========================================================*/

    /**
     * Publisher of model expressed in the schema.
     * cardinality: 1..1
     */
    public String getRmPublisher() {
        return rmPublisher;
    }

    public void setRmPublisher(String value) {
        if (value == null) {
            throw new NullPointerException(" Setting property:rmPublisher failed, it has cardinality NonNull, but is null");
        }
        this.rmPublisher = rmPublisher;
    }

    /**
     * Release of model expressed in the schema as a 3-part numeric, e.g.
     * "3.1.0" .
     * cardinality: 1..1
     */
    public String getRmRelease() {
        return rmRelease;
    }

    public void setRmRelease(String value) {
        if (value == null) {
            throw new NullPointerException(" Setting property:rmRelease failed, it has cardinality NonNull, but is null");
        }
        this.rmRelease = rmRelease;
    }

    //***** BmmSchema *****

    /*=========================================================*/
    /* * BUILD PATTERN AND CONSTRUCTOR * */
    /*=========================================================*/


    protected BmmSchema() {
    }

    protected BmmSchema(
            String bmmVersion,
            Map<string, bmmIncludeSpec> includes,
            BmmModel bmmModel,
            BmmSchemaState state,
            String modelName,
            String schemaName,
            String schemaRevision,
            String schemaLifecycleState,
            String schemaAuthor,
            String schemaDescription,
            List<string> schemaContributors,
            String rmPublisher,
            String rmRelease
    ) {
        if (bmmVersion == null) {
            throw new NullPointerException("Property:bmmVersion has cardinality NonNull, but is null");
        }
        if (state == null) {
            throw new NullPointerException("Property:state has cardinality NonNull, but is null");
        }
        if (schemaName == null) {
            throw new NullPointerException("Property:schemaName has cardinality NonNull, but is null");
        }
        if (schemaRevision == null) {
            throw new NullPointerException("Property:schemaRevision has cardinality NonNull, but is null");
        }
        if (schemaLifecycleState == null) {
            throw new NullPointerException("Property:schemaLifecycleState has cardinality NonNull, but is null");
        }
        if (schemaAuthor == null) {
            throw new NullPointerException("Property:schemaAuthor has cardinality NonNull, but is null");
        }
        if (schemaDescription == null) {
            throw new NullPointerException("Property:schemaDescription has cardinality NonNull, but is null");
        }
        if (rmPublisher == null) {
            throw new NullPointerException("Property:rmPublisher has cardinality NonNull, but is null");
        }
        if (rmRelease == null) {
            throw new NullPointerException("Property:rmRelease has cardinality NonNull, but is null");
        }
        this.bmmVersion = bmmVersion;
        this.includes = includes;
        this.bmmModel = bmmModel;
        this.state = state;
        this.modelName = modelName;
        this.schemaName = schemaName;
        this.schemaRevision = schemaRevision;
        this.schemaLifecycleState = schemaLifecycleState;
        this.schemaAuthor = schemaAuthor;
        this.schemaDescription = schemaDescription;
        this.schemaContributors = schemaContributors;
        this.rmPublisher = rmPublisher;
        this.rmRelease = rmRelease;
    }


    //***** BmmSchema *****

    /*=========================================================*/
    /* * TOSTRING, EQUALS AND HASHCODE * */
    /*=========================================================*/


    public boolean equals(Object object) {
        if (this == object) return true;
        if (object == null || getClass() != object.getClass()) return false;
        if (!super.equals(object)) return false;
        BmmSchema that = (BmmSchema) object;
        return
                Objects.equals(bmmVersion, that.bmmVersion) &&
                        Objects.equals(includes, that.includes) &&
                        Objects.equals(bmmModel, that.bmmModel) &&
                        Objects.equals(state, that.state) &&
                        Objects.equals(modelName, that.modelName) &&
                        Objects.equals(schemaName, that.schemaName) &&
                        Objects.equals(schemaRevision, that.schemaRevision) &&
                        Objects.equals(schemaLifecycleState, that.schemaLifecycleState) &&
                        Objects.equals(schemaAuthor, that.schemaAuthor) &&
                        Objects.equals(schemaDescription, that.schemaDescription) &&
                        Objects.equals(schemaContributors, that.schemaContributors) &&
                        Objects.equals(rmPublisher, that.rmPublisher) &&
                        Objects.equals(rmRelease, that.rmRelease);
    }

    public int hashCode() {
        return Objects.hash(
                super.hashCode(),
                bmmVersion,
                includes,
                bmmModel,
                state,
                modelName,
                schemaName,
                schemaRevision,
                schemaLifecycleState,
                schemaAuthor,
                schemaDescription,
                schemaContributors,
                rmPublisher,
                rmRelease
        );
    }

    @Override
    public String toString() {
        return
                "BmmSchema {" +
                        "bmmVersion='" + bmmVersion + '\'' +
                        "includes='" + includes + '\'' +
                        "bmmModel='" + bmmModel + '\'' +
                        "state='" + state + '\'' +
                        "modelName='" + modelName + '\'' +
                        "schemaName='" + schemaName + '\'' +
                        "schemaRevision='" + schemaRevision + '\'' +
                        "schemaLifecycleState='" + schemaLifecycleState + '\'' +
                        "schemaAuthor='" + schemaAuthor + '\'' +
                        "schemaDescription='" + schemaDescription + '\'' +
                        "schemaContributors='" + schemaContributors + '\'' +
                        "rmPublisher='" + rmPublisher + '\'' +
                        "rmRelease='" + rmRelease + '\'' +
                        '}';
    }

}

/**
 * ***** BEGIN LICENSE BLOCK *****
 * <p>
 * ISC License
 * <p>
 * Copyright (c) 2020, Bert Verhees
 * <p>
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 * <p>
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 * <p>
 * ***** END LICENSE BLOCK *****
 */
